{"ast":null,"code":"const {\n  maskSensitiveValues\n} = require(\"./maskFields\");\nconst os = require(\"os\");\nconst fetch = require(\"node-fetch\");\nconst stackTrace = require(\"stack-trace\");\nconst VERSION = require(\"../package.json\").version;\n\n/**\n * Prepares the payload which is sent to Treblle.\n *\n * @param {object} Express request object\n * @param {object} Express response object\n * @param {object} settings\n * @param {string} settings.apiKey Treblle API Key\n * @param {string} settings.projectId Treblle Project ID\n * @param {number[]} settings.requestStartTime when the request started\n * @param {object} settings.fieldsToMaskMap map of fields to mask\n */\nconst generateTrebllePayload = function (req, res, _ref) {\n  let {\n    apiKey,\n    projectId,\n    requestStartTime,\n    error,\n    fieldsToMaskMap\n  } = _ref;\n  const payload = req.method === \"GET\" ? req.query : req.body;\n  const parsedPayload = getPayload(payload);\n  const maskedRequestPayload = maskSensitiveValues(parsedPayload, fieldsToMaskMap);\n  const responseHeaders = res.getHeaders();\n  let errors = [];\n\n  // We should be able to parse this, but you never know if users will try doing something weird...\n  let maskedResponseBody;\n  try {\n    let originalResponseBody = res.__treblle_body_response;\n    // if the response is streamed it could be a buffer\n    // so we'll convert it to a string first\n    if (Buffer.isBuffer(originalResponseBody)) {\n      originalResponseBody = originalResponseBody.toString(\"utf8\");\n    }\n    if (typeof originalResponseBody === \"string\") {\n      let parsedResponseBody = JSON.parse(originalResponseBody);\n      maskedResponseBody = maskSensitiveValues(parsedResponseBody, fieldsToMaskMap);\n    } else if (typeof originalResponseBody === \"object\") {\n      maskedResponseBody = maskSensitiveValues(originalResponseBody, fieldsToMaskMap);\n    }\n  } catch {\n    // if we can't parse the body we'll leave it empty and set an error\n    errors.push({\n      source: \"onShutdown\",\n      type: \"INVALID_JSON\",\n      message: \"Invalid JSON format\",\n      file: null,\n      line: null\n    });\n  }\n  const protocol = `${req.protocol.toUpperCase()}/${req.httpVersion}`;\n\n  // get rid of the workaround body, we don't need it anymore\n  res.__treblle_body_response = null;\n  if (error) {\n    const trace = stackTrace.parse(error);\n    errors.push({\n      source: \"onException\",\n      type: \"UNHANDLED_EXCEPTION\",\n      message: error.message,\n      file: trace[0].getFileName(),\n      line: trace[0].getLineNumber()\n    });\n  }\n  let dataToSend = {\n    api_key: apiKey,\n    project_id: projectId,\n    version: VERSION,\n    sdk: \"node\",\n    data: {\n      server: {\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        os: {\n          name: os.platform(),\n          release: os.release(),\n          architecture: os.arch()\n        },\n        software: null,\n        signature: null,\n        protocol: protocol\n      },\n      language: {\n        name: \"node\",\n        version: process.version\n      },\n      request: {\n        timestamp: new Date().toISOString().replace(\"T\", \" \").substr(0, 19),\n        ip: req.ip,\n        url: getRequestUrl(req),\n        user_agent: req.get(\"user-agent\"),\n        method: req.method,\n        headers: maskSensitiveValues(req.headers, fieldsToMaskMap),\n        body: maskedRequestPayload !== undefined ? maskedRequestPayload : null\n      },\n      response: {\n        headers: maskSensitiveValues(responseHeaders, fieldsToMaskMap),\n        code: res.statusCode,\n        size: res._contentLength,\n        load_time: getRequestDuration(requestStartTime),\n        body: maskedResponseBody !== undefined ? maskedResponseBody : null\n      },\n      errors: errors\n    }\n  };\n  return dataToSend;\n};\n\n/**\n * Prepares the payload which is sent to Treblle.\n *\n * @param {object} Koa context object\n * @param {object} settings\n * @param {string} settings.apiKey Treblle API Key\n * @param {string} settings.projectId Treblle Project ID\n * @param {number[]} settings.requestStartTime when the request started\n * @param {object} settings.fieldsToMaskMap map of fields to mask\n */\nconst generateKoaTrebllePayload = function (koaContext, _ref2) {\n  let {\n    apiKey,\n    projectId,\n    requestStartTime,\n    error,\n    fieldsToMaskMap\n  } = _ref2;\n  const payload = koaContext.request.method === \"GET\" ? koaContext.request.query : koaContext.request.body;\n  const parsedPayload = getPayload(payload);\n  const maskedRequestPayload = maskSensitiveValues(parsedPayload, fieldsToMaskMap);\n  const responseHeaders = koaContext.response.headers;\n  let errors = [];\n\n  // We should be able to parse this, but you never know if users will try doing something weird...\n  // TODO - figure out Koa buffers & streaming\n  let maskedResponseBody;\n  try {\n    let originalResponseBody = koaContext.response.body;\n    // if the response is streamed it could be a buffer\n    // so we'll convert it to a string first\n    if (Buffer.isBuffer(originalResponseBody)) {\n      originalResponseBody = originalResponseBody.toString(\"utf8\");\n    }\n    if (typeof originalResponseBody === \"string\") {\n      let parsedResponseBody = JSON.parse(originalResponseBody);\n      maskedResponseBody = maskSensitiveValues(parsedResponseBody, fieldsToMaskMap);\n    } else if (typeof originalResponseBody === \"object\") {\n      maskedResponseBody = maskSensitiveValues(originalResponseBody, fieldsToMaskMap);\n    }\n  } catch {\n    // if we can't parse the body we'll leave it empty and set an error\n    errors.push({\n      source: \"onShutdown\",\n      type: \"INVALID_JSON\",\n      message: \"Invalid JSON format\",\n      file: null,\n      line: null\n    });\n  }\n  const protocol = `${koaContext.request.protocol.toUpperCase()}/${koaContext.request.req.httpVersion}`;\n  if (error) {\n    const trace = stackTrace.parse(error);\n    errors.push({\n      source: \"onException\",\n      type: \"UNHANDLED_EXCEPTION\",\n      message: error.message,\n      file: trace[0].getFileName(),\n      line: trace[0].getLineNumber()\n    });\n  }\n  let dataToSend = {\n    api_key: apiKey,\n    project_id: projectId,\n    version: VERSION,\n    sdk: \"node\",\n    data: {\n      server: {\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        os: {\n          name: os.platform(),\n          release: os.release(),\n          architecture: os.arch()\n        },\n        software: null,\n        signature: null,\n        protocol: protocol\n      },\n      language: {\n        name: \"node\",\n        version: process.version\n      },\n      request: {\n        timestamp: new Date().toISOString().replace(\"T\", \" \").substr(0, 19),\n        ip: koaContext.request.ip,\n        url: getRequestUrl(koaContext.request),\n        user_agent: koaContext.request.header[\"user-agent\"],\n        method: koaContext.request.method,\n        headers: maskSensitiveValues(koaContext.request.headers, fieldsToMaskMap),\n        body: maskedRequestPayload !== undefined ? maskedRequestPayload : null\n      },\n      response: {\n        headers: maskSensitiveValues(responseHeaders, fieldsToMaskMap),\n        code: koaContext.response.status,\n        size: koaContext.response.length || null,\n        load_time: getRequestDuration(requestStartTime),\n        body: maskedResponseBody !== undefined ? maskedResponseBody : null\n      },\n      errors: errors\n    }\n  };\n  return dataToSend;\n};\nfunction sendExpressPayloadToTreblle(req, res, _ref3) {\n  let {\n    apiKey,\n    projectId,\n    requestStartTime,\n    error,\n    fieldsToMaskMap,\n    showErrors\n  } = _ref3;\n  let trebllePayload = generateTrebllePayload(req, res, {\n    apiKey,\n    projectId,\n    requestStartTime,\n    error,\n    fieldsToMaskMap\n  });\n  sendPayloadToTreblleApi({\n    apiKey,\n    trebllePayload,\n    showErrors\n  });\n}\nfunction sendKoaPayloadToTreblle(koaContext, _ref4) {\n  let {\n    apiKey,\n    projectId,\n    requestStartTime,\n    fieldsToMaskMap,\n    showErrors,\n    error\n  } = _ref4;\n  let trebllePayload = generateKoaTrebllePayload(koaContext, {\n    apiKey,\n    projectId,\n    requestStartTime,\n    error,\n    fieldsToMaskMap\n  });\n  sendPayloadToTreblleApi({\n    apiKey,\n    trebllePayload,\n    showErrors\n  });\n}\nfunction sendPayloadToTreblleApi(_ref5) {\n  let {\n    apiKey,\n    trebllePayload,\n    showErrors\n  } = _ref5;\n  let f;\n  if (typeof fetch === \"function\") {\n    f = fetch;\n  } else if (fetch && typeof fetch.default === \"function\") {\n    f = fetch.default;\n  } else {\n    if (showErrors) {\n      console.warn(\"Treblle error: fetch is not defined\");\n    }\n    return;\n  }\n  f(\"https://rocknrolla.treblle.com\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-api-key\": apiKey\n    },\n    body: JSON.stringify(trebllePayload)\n  }).then(response => {\n    if (showErrors && response.ok === false) {\n      logTreblleResponseError(response);\n    }\n  }, error => {\n    if (showErrors) {\n      logRequestFailed(error);\n    }\n  });\n}\nasync function logTreblleResponseError(response) {\n  try {\n    const responseBody = await response.json();\n    logError(response, responseBody);\n    return;\n  } catch (_error) {\n    // ignore _error here, it means the response wasn't JSON\n  }\n  try {\n    const responseBody = await response.text();\n    logError(response, responseBody);\n    return;\n  } catch (_error) {\n    // ignore _error here, it means the response wasn't text\n  }\n  logError(response);\n}\nfunction logError(response, responseBody) {\n  console.log(`[error] Sending data to Treblle failed - status: ${response.statusText} (${response.status})`, responseBody);\n}\nfunction logRequestFailed(error) {\n  console.error(\"[error] Sending data to Treblle failed (it's possibly a network error)\", error);\n}\n\n/**\n * Calculates the request duration.\n *\n * @param {number[]} startTime\n * @returns {number}\n */\nfunction getRequestDuration(startTime) {\n  const NS_PER_SEC = 1e9;\n  const NS_TO_MICRO = 1e3;\n  const diff = process.hrtime(startTime);\n  const microseconds = (diff[0] * NS_PER_SEC + diff[1]) / NS_TO_MICRO;\n  return Math.ceil(microseconds);\n}\nfunction getRequestUrl(req) {\n  const fullUrl = `${req.protocol}://${req.get(\"host\")}${req.originalUrl}`;\n  return fullUrl;\n}\nfunction getPayload(payload) {\n  if (typeof payload === \"object\") return payload;\n  if (typeof payload === \"string\") {\n    try {\n      return JSON.parse(payload);\n    } catch (error) {\n      // if we can't parse it we'll just return null\n      return null;\n    }\n  }\n}\nmodule.exports = {\n  sendExpressPayloadToTreblle,\n  sendKoaPayloadToTreblle,\n  sendPayloadToTreblleApi\n};","map":{"version":3,"names":["maskSensitiveValues","require","os","fetch","stackTrace","VERSION","version","generateTrebllePayload","req","res","apiKey","projectId","requestStartTime","error","fieldsToMaskMap","payload","method","query","body","parsedPayload","getPayload","maskedRequestPayload","responseHeaders","getHeaders","errors","maskedResponseBody","originalResponseBody","__treblle_body_response","Buffer","isBuffer","toString","parsedResponseBody","JSON","parse","push","source","type","message","file","line","protocol","toUpperCase","httpVersion","trace","getFileName","getLineNumber","dataToSend","api_key","project_id","sdk","data","server","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","name","platform","release","architecture","arch","software","signature","language","process","request","timestamp","Date","toISOString","replace","substr","ip","url","getRequestUrl","user_agent","get","headers","undefined","response","code","statusCode","size","_contentLength","load_time","getRequestDuration","generateKoaTrebllePayload","koaContext","header","status","length","sendExpressPayloadToTreblle","showErrors","trebllePayload","sendPayloadToTreblleApi","sendKoaPayloadToTreblle","f","default","console","warn","stringify","then","ok","logTreblleResponseError","logRequestFailed","responseBody","json","logError","_error","text","log","statusText","startTime","NS_PER_SEC","NS_TO_MICRO","diff","hrtime","microseconds","Math","ceil","fullUrl","originalUrl","module","exports"],"sources":["A:/Work/PersonalDevelopment/03 {React API}/api_app/node_modules/treblle/src/sender.js"],"sourcesContent":["const { maskSensitiveValues } = require(\"./maskFields\");\nconst os = require(\"os\");\nconst fetch = require(\"node-fetch\");\nconst stackTrace = require(\"stack-trace\");\nconst VERSION = require(\"../package.json\").version;\n\n/**\n * Prepares the payload which is sent to Treblle.\n *\n * @param {object} Express request object\n * @param {object} Express response object\n * @param {object} settings\n * @param {string} settings.apiKey Treblle API Key\n * @param {string} settings.projectId Treblle Project ID\n * @param {number[]} settings.requestStartTime when the request started\n * @param {object} settings.fieldsToMaskMap map of fields to mask\n */\nconst generateTrebllePayload = function (\n  req,\n  res,\n  { apiKey, projectId, requestStartTime, error, fieldsToMaskMap }\n) {\n  const payload = req.method === \"GET\" ? req.query : req.body;\n  const parsedPayload = getPayload(payload);\n  const maskedRequestPayload = maskSensitiveValues(\n    parsedPayload,\n    fieldsToMaskMap\n  );\n\n  const responseHeaders = res.getHeaders();\n\n  let errors = [];\n\n  // We should be able to parse this, but you never know if users will try doing something weird...\n  let maskedResponseBody;\n  try {\n    let originalResponseBody = res.__treblle_body_response;\n    // if the response is streamed it could be a buffer\n    // so we'll convert it to a string first\n    if (Buffer.isBuffer(originalResponseBody)) {\n      originalResponseBody = originalResponseBody.toString(\"utf8\");\n    }\n\n    if (typeof originalResponseBody === \"string\") {\n      let parsedResponseBody = JSON.parse(originalResponseBody);\n      maskedResponseBody = maskSensitiveValues(\n        parsedResponseBody,\n        fieldsToMaskMap\n      );\n    } else if (typeof originalResponseBody === \"object\") {\n      maskedResponseBody = maskSensitiveValues(\n        originalResponseBody,\n        fieldsToMaskMap\n      );\n    }\n  } catch {\n    // if we can't parse the body we'll leave it empty and set an error\n    errors.push({\n      source: \"onShutdown\",\n      type: \"INVALID_JSON\",\n      message: \"Invalid JSON format\",\n      file: null,\n      line: null,\n    });\n  }\n\n  const protocol = `${req.protocol.toUpperCase()}/${req.httpVersion}`;\n\n  // get rid of the workaround body, we don't need it anymore\n  res.__treblle_body_response = null;\n\n  if (error) {\n    const trace = stackTrace.parse(error);\n\n    errors.push({\n      source: \"onException\",\n      type: \"UNHANDLED_EXCEPTION\",\n      message: error.message,\n      file: trace[0].getFileName(),\n      line: trace[0].getLineNumber(),\n    });\n  }\n\n  let dataToSend = {\n    api_key: apiKey,\n    project_id: projectId,\n    version: VERSION,\n    sdk: \"node\",\n    data: {\n      server: {\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        os: {\n          name: os.platform(),\n          release: os.release(),\n          architecture: os.arch(),\n        },\n        software: null,\n        signature: null,\n        protocol: protocol,\n      },\n      language: {\n        name: \"node\",\n        version: process.version,\n      },\n      request: {\n        timestamp: new Date().toISOString().replace(\"T\", \" \").substr(0, 19),\n        ip: req.ip,\n        url: getRequestUrl(req),\n        user_agent: req.get(\"user-agent\"),\n        method: req.method,\n        headers: maskSensitiveValues(req.headers, fieldsToMaskMap),\n        body: maskedRequestPayload !== undefined ? maskedRequestPayload : null,\n      },\n      response: {\n        headers: maskSensitiveValues(responseHeaders, fieldsToMaskMap),\n        code: res.statusCode,\n        size: res._contentLength,\n        load_time: getRequestDuration(requestStartTime),\n        body: maskedResponseBody !== undefined ? maskedResponseBody : null,\n      },\n      errors: errors,\n    },\n  };\n\n  return dataToSend;\n};\n\n/**\n * Prepares the payload which is sent to Treblle.\n *\n * @param {object} Koa context object\n * @param {object} settings\n * @param {string} settings.apiKey Treblle API Key\n * @param {string} settings.projectId Treblle Project ID\n * @param {number[]} settings.requestStartTime when the request started\n * @param {object} settings.fieldsToMaskMap map of fields to mask\n */\nconst generateKoaTrebllePayload = function (\n  koaContext,\n  { apiKey, projectId, requestStartTime, error, fieldsToMaskMap }\n) {\n  const payload =\n    koaContext.request.method === \"GET\"\n      ? koaContext.request.query\n      : koaContext.request.body;\n  const parsedPayload = getPayload(payload);\n  const maskedRequestPayload = maskSensitiveValues(\n    parsedPayload,\n    fieldsToMaskMap\n  );\n\n  const responseHeaders = koaContext.response.headers;\n\n  let errors = [];\n\n  // We should be able to parse this, but you never know if users will try doing something weird...\n  // TODO - figure out Koa buffers & streaming\n  let maskedResponseBody;\n  try {\n    let originalResponseBody = koaContext.response.body;\n    // if the response is streamed it could be a buffer\n    // so we'll convert it to a string first\n    if (Buffer.isBuffer(originalResponseBody)) {\n      originalResponseBody = originalResponseBody.toString(\"utf8\");\n    }\n\n    if (typeof originalResponseBody === \"string\") {\n      let parsedResponseBody = JSON.parse(originalResponseBody);\n      maskedResponseBody = maskSensitiveValues(\n        parsedResponseBody,\n        fieldsToMaskMap\n      );\n    } else if (typeof originalResponseBody === \"object\") {\n      maskedResponseBody = maskSensitiveValues(\n        originalResponseBody,\n        fieldsToMaskMap\n      );\n    }\n  } catch {\n    // if we can't parse the body we'll leave it empty and set an error\n    errors.push({\n      source: \"onShutdown\",\n      type: \"INVALID_JSON\",\n      message: \"Invalid JSON format\",\n      file: null,\n      line: null,\n    });\n  }\n\n  const protocol = `${koaContext.request.protocol.toUpperCase()}/${\n    koaContext.request.req.httpVersion\n  }`;\n\n  if (error) {\n    const trace = stackTrace.parse(error);\n\n    errors.push({\n      source: \"onException\",\n      type: \"UNHANDLED_EXCEPTION\",\n      message: error.message,\n      file: trace[0].getFileName(),\n      line: trace[0].getLineNumber(),\n    });\n  }\n\n  let dataToSend = {\n    api_key: apiKey,\n    project_id: projectId,\n    version: VERSION,\n    sdk: \"node\",\n    data: {\n      server: {\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        os: {\n          name: os.platform(),\n          release: os.release(),\n          architecture: os.arch(),\n        },\n        software: null,\n        signature: null,\n        protocol: protocol,\n      },\n      language: {\n        name: \"node\",\n        version: process.version,\n      },\n      request: {\n        timestamp: new Date().toISOString().replace(\"T\", \" \").substr(0, 19),\n        ip: koaContext.request.ip,\n        url: getRequestUrl(koaContext.request),\n        user_agent: koaContext.request.header[\"user-agent\"],\n        method: koaContext.request.method,\n        headers: maskSensitiveValues(\n          koaContext.request.headers,\n          fieldsToMaskMap\n        ),\n        body: maskedRequestPayload !== undefined ? maskedRequestPayload : null,\n      },\n      response: {\n        headers: maskSensitiveValues(responseHeaders, fieldsToMaskMap),\n        code: koaContext.response.status,\n        size: koaContext.response.length || null,\n        load_time: getRequestDuration(requestStartTime),\n        body: maskedResponseBody !== undefined ? maskedResponseBody : null,\n      },\n      errors: errors,\n    },\n  };\n\n  return dataToSend;\n};\n\nfunction sendExpressPayloadToTreblle(\n  req,\n  res,\n  { apiKey, projectId, requestStartTime, error, fieldsToMaskMap, showErrors }\n) {\n  let trebllePayload = generateTrebllePayload(req, res, {\n    apiKey,\n    projectId,\n    requestStartTime,\n    error,\n    fieldsToMaskMap,\n  });\n\n  sendPayloadToTreblleApi({ apiKey, trebllePayload, showErrors });\n}\n\nfunction sendKoaPayloadToTreblle(\n  koaContext,\n  { apiKey, projectId, requestStartTime, fieldsToMaskMap, showErrors, error }\n) {\n  let trebllePayload = generateKoaTrebllePayload(koaContext, {\n    apiKey,\n    projectId,\n    requestStartTime,\n    error,\n    fieldsToMaskMap,\n  });\n\n  sendPayloadToTreblleApi({ apiKey, trebllePayload, showErrors });\n}\n\nfunction sendPayloadToTreblleApi({ apiKey, trebllePayload, showErrors }) {\n  let f;\n  if (typeof fetch === \"function\") {\n    f = fetch;\n  } else if (fetch && typeof fetch.default === \"function\") {\n    f = fetch.default;\n  } else {\n    if (showErrors) {\n      console.warn(\"Treblle error: fetch is not defined\");\n    }\n    return;\n  }\n\n  f(\"https://rocknrolla.treblle.com\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-api-key\": apiKey,\n    },\n    body: JSON.stringify(trebllePayload),\n  }).then(\n    (response) => {\n      if (showErrors && response.ok === false) {\n        logTreblleResponseError(response);\n      }\n    },\n    (error) => {\n      if (showErrors) {\n        logRequestFailed(error);\n      }\n    }\n  );\n}\n\nasync function logTreblleResponseError(response) {\n  try {\n    const responseBody = await response.json();\n    logError(response, responseBody);\n    return;\n  } catch (_error) {\n    // ignore _error here, it means the response wasn't JSON\n  }\n\n  try {\n    const responseBody = await response.text();\n    logError(response, responseBody);\n    return;\n  } catch (_error) {\n    // ignore _error here, it means the response wasn't text\n  }\n\n  logError(response);\n}\n\nfunction logError(response, responseBody) {\n  console.log(\n    `[error] Sending data to Treblle failed - status: ${response.statusText} (${response.status})`,\n    responseBody\n  );\n}\n\nfunction logRequestFailed(error) {\n  console.error(\n    \"[error] Sending data to Treblle failed (it's possibly a network error)\",\n    error\n  );\n}\n\n/**\n * Calculates the request duration.\n *\n * @param {number[]} startTime\n * @returns {number}\n */\nfunction getRequestDuration(startTime) {\n  const NS_PER_SEC = 1e9;\n  const NS_TO_MICRO = 1e3;\n  const diff = process.hrtime(startTime);\n\n  const microseconds = (diff[0] * NS_PER_SEC + diff[1]) / NS_TO_MICRO;\n\n  return Math.ceil(microseconds);\n}\n\nfunction getRequestUrl(req) {\n  const fullUrl = `${req.protocol}://${req.get(\"host\")}${req.originalUrl}`;\n  return fullUrl;\n}\n\nfunction getPayload(payload) {\n  if (typeof payload === \"object\") return payload;\n  if (typeof payload === \"string\") {\n    try {\n      return JSON.parse(payload);\n    } catch (error) {\n      // if we can't parse it we'll just return null\n      return null;\n    }\n  }\n}\n\nmodule.exports = {\n  sendExpressPayloadToTreblle,\n  sendKoaPayloadToTreblle,\n  sendPayloadToTreblleApi,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}