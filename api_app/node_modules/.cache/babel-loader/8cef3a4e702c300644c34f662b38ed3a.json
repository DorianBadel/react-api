{"ast":null,"code":"const stackTrace = require(\"stack-trace\");\nconst version = require(\"../../package.json\").version;\nconst {\n  maskSensitiveValues\n} = require(\"../maskFields\");\nconst {\n  ContentType\n} = require(\"../consts\");\nasync function generatePayload(request, response, _ref) {\n  let {\n    apiKey,\n    projectId,\n    fieldsToMaskMap,\n    requestExecutionTime,\n    error\n  } = _ref;\n  const errors = [];\n  const requestBody = await parseRequest(request);\n  const maskedRequestBody = requestBody ? maskSensitiveValues(requestBody, fieldsToMaskMap) : null;\n  let maskedResponseBody = null;\n  try {\n    const responseBody = response ? await parseResponse(response) : null;\n    maskedResponseBody = responseBody ? maskSensitiveValues(responseBody, fieldsToMaskMap) : null;\n  } catch (err) {\n    errors.push({\n      source: \"onShutdown\",\n      type: \"INVALID_JSON\",\n      message: \"Response in invalid JSON format\",\n      file: null,\n      line: null\n    });\n  }\n  if (error) {\n    const trace = stackTrace.parse(error);\n    errors.push({\n      source: \"onException\",\n      type: \"UNHANDLED_EXCEPTION\",\n      message: error.message,\n      file: trace[0].getFileName(),\n      line: trace[0].getLineNumber()\n    });\n  }\n  const requestHeaders = maskSensitiveValues(parseHeaders(request && request.headers), fieldsToMaskMap);\n  const responseHeaders = maskSensitiveValues(parseHeaders(response && response.headers), fieldsToMaskMap);\n  return {\n    api_key: apiKey,\n    project_id: projectId,\n    version: version,\n    sdk: \"cloudflare\",\n    data: {\n      server: {\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        os: {\n          name: \"Cloudflare Workers Runtime\"\n        },\n        software: null,\n        signature: null,\n        protocol: request.cf.httpProtocol\n      },\n      language: {\n        name: \"js\"\n      },\n      request: {\n        timestamp: new Date().toISOString().replace(\"T\", \" \").substr(0, 19),\n        ip: request.headers.get(\"x-real-ip\"),\n        url: request.url,\n        user_agent: request.headers.get(\"user-agent\"),\n        method: request.method,\n        headers: requestHeaders,\n        body: maskedRequestBody ? maskedRequestBody : null\n      },\n      response: {\n        headers: response ? responseHeaders : null,\n        code: response ? response.status : 500,\n        size: response ? getSize(maskedResponseBody) : 0,\n        load_time: requestExecutionTime > 0 ? requestExecutionTime * 1000 : 1000,\n        body: maskedResponseBody ? maskedResponseBody : null\n      },\n      errors: errors\n    }\n  };\n}\nconst parseRequest = async request => {\n  const requestContentType = request.headers.get(\"content-type\");\n  if (request.method === \"GET\") {\n    const requestBody = {};\n    for (let pair of new URL(request.url).searchParams.entries()) {\n      requestBody[pair[0]] = pair[1];\n    }\n    return requestBody;\n  } else if (requestContentType.includes(ContentType.MultipartFormData) || requestContentType.includes(ContentType.ApplicationFormData)) {\n    const requestBody = {};\n    const body = await request.formData();\n    for (let pair of body.entries()) {\n      requestBody[pair[0]] = pair[1];\n    }\n    return requestBody;\n  } else if (requestContentType.includes(ContentType.Text)) {\n    return request.text();\n  } else if (requestContentType.includes(ContentType.Json)) {\n    return request.json();\n  } else {\n    return null;\n  }\n};\nconst parseResponse = async response => {\n  const responseContentType = response.headers.get(\"content-type\");\n  if (responseContentType.includes(ContentType.Text)) {\n    return response.text();\n  } else if (responseContentType.includes(ContentType.Json)) {\n    return response.json();\n  } else {\n    const content = await response.text();\n    if (content && content.length > 0) {\n      try {\n        return JSON.parse(content);\n      } catch (e) {\n        return content;\n      }\n    }\n    return null;\n  }\n};\nconst parseHeaders = headers => {\n  if (!headers) {\n    return null;\n  }\n  const hdrs = {};\n  for (let pair of headers.entries()) {\n    hdrs[pair[0]] = pair[1];\n  }\n  return hdrs;\n};\nconst getSize = item => {\n  if (!item) {\n    return 0;\n  } else if (typeof item === \"string\") {\n    return item.length;\n  } else if (typeof item === \"object\") {\n    return JSON.stringify(item).length;\n  } else {\n    return 0;\n  }\n};\nmodule.exports = {\n  generatePayload\n};","map":{"version":3,"names":["stackTrace","require","version","maskSensitiveValues","ContentType","generatePayload","request","response","apiKey","projectId","fieldsToMaskMap","requestExecutionTime","error","errors","requestBody","parseRequest","maskedRequestBody","maskedResponseBody","responseBody","parseResponse","err","push","source","type","message","file","line","trace","parse","getFileName","getLineNumber","requestHeaders","parseHeaders","headers","responseHeaders","api_key","project_id","sdk","data","server","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","os","name","software","signature","protocol","cf","httpProtocol","language","timestamp","Date","toISOString","replace","substr","ip","get","url","user_agent","method","body","code","status","size","getSize","load_time","requestContentType","pair","URL","searchParams","entries","includes","MultipartFormData","ApplicationFormData","formData","Text","text","Json","json","responseContentType","content","length","JSON","e","hdrs","item","stringify","module","exports"],"sources":["A:/Work/PersonalDevelopment/03 {React API}/api_app/node_modules/treblle/src/cloudflare-workers/generate-payload.js"],"sourcesContent":["const stackTrace = require(\"stack-trace\");\n\nconst version = require(\"../../package.json\").version;\nconst { maskSensitiveValues } = require(\"../maskFields\");\nconst { ContentType } = require(\"../consts\");\n\nasync function generatePayload(\n  request,\n  response,\n  { apiKey, projectId, fieldsToMaskMap, requestExecutionTime, error }\n) {\n  const errors = [];\n\n  const requestBody = await parseRequest(request);\n  const maskedRequestBody = requestBody\n    ? maskSensitiveValues(requestBody, fieldsToMaskMap)\n    : null;\n\n  let maskedResponseBody = null;\n  try {\n    const responseBody = response ? await parseResponse(response) : null;\n    maskedResponseBody = responseBody\n      ? maskSensitiveValues(responseBody, fieldsToMaskMap)\n      : null;\n  } catch (err) {\n    errors.push({\n      source: \"onShutdown\",\n      type: \"INVALID_JSON\",\n      message: \"Response in invalid JSON format\",\n      file: null,\n      line: null,\n    });\n  }\n\n  if (error) {\n    const trace = stackTrace.parse(error);\n    errors.push({\n      source: \"onException\",\n      type: \"UNHANDLED_EXCEPTION\",\n      message: error.message,\n      file: trace[0].getFileName(),\n      line: trace[0].getLineNumber(),\n    });\n  }\n\n  const requestHeaders = maskSensitiveValues(\n    parseHeaders(request && request.headers),\n    fieldsToMaskMap\n  );\n  const responseHeaders = maskSensitiveValues(\n    parseHeaders(response && response.headers),\n    fieldsToMaskMap\n  );\n\n  return {\n    api_key: apiKey,\n    project_id: projectId,\n    version: version,\n    sdk: \"cloudflare\",\n    data: {\n      server: {\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        os: {\n          name: \"Cloudflare Workers Runtime\",\n        },\n        software: null,\n        signature: null,\n        protocol: request.cf.httpProtocol,\n      },\n      language: {\n        name: \"js\",\n      },\n      request: {\n        timestamp: new Date().toISOString().replace(\"T\", \" \").substr(0, 19),\n        ip: request.headers.get(\"x-real-ip\"),\n        url: request.url,\n        user_agent: request.headers.get(\"user-agent\"),\n        method: request.method,\n        headers: requestHeaders,\n        body: maskedRequestBody ? maskedRequestBody : null,\n      },\n      response: {\n        headers: response ? responseHeaders : null,\n        code: response ? response.status : 500,\n        size: response ? getSize(maskedResponseBody) : 0,\n        load_time:\n          requestExecutionTime > 0 ? requestExecutionTime * 1000 : 1000,\n        body: maskedResponseBody ? maskedResponseBody : null,\n      },\n      errors: errors,\n    },\n  };\n}\n\nconst parseRequest = async (request) => {\n  const requestContentType = request.headers.get(\"content-type\");\n\n  if (request.method === \"GET\") {\n    const requestBody = {};\n    for (let pair of new URL(request.url).searchParams.entries()) {\n      requestBody[pair[0]] = pair[1];\n    }\n    return requestBody;\n  } else if (\n    requestContentType.includes(ContentType.MultipartFormData) ||\n    requestContentType.includes(ContentType.ApplicationFormData)\n  ) {\n    const requestBody = {};\n    const body = await request.formData();\n    for (let pair of body.entries()) {\n      requestBody[pair[0]] = pair[1];\n    }\n    return requestBody;\n  } else if (requestContentType.includes(ContentType.Text)) {\n    return request.text();\n  } else if (requestContentType.includes(ContentType.Json)) {\n    return request.json();\n  } else {\n    return null;\n  }\n};\n\nconst parseResponse = async (response) => {\n  const responseContentType = response.headers.get(\"content-type\");\n  if (responseContentType.includes(ContentType.Text)) {\n    return response.text();\n  } else if (responseContentType.includes(ContentType.Json)) {\n    return response.json();\n  } else {\n    const content = await response.text();\n    if (content && content.length > 0) {\n      try {\n        return JSON.parse(content);\n      } catch (e) {\n        return content;\n      }\n    }\n    return null;\n  }\n};\n\nconst parseHeaders = (headers) => {\n  if (!headers) {\n    return null;\n  }\n  const hdrs = {};\n  for (let pair of headers.entries()) {\n    hdrs[pair[0]] = pair[1];\n  }\n  return hdrs;\n};\n\nconst getSize = (item) => {\n  if (!item) {\n    return 0;\n  } else if (typeof item === \"string\") {\n    return item.length;\n  } else if (typeof item === \"object\") {\n    return JSON.stringify(item).length;\n  } else {\n    return 0;\n  }\n};\n\nmodule.exports = {\n  generatePayload,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}