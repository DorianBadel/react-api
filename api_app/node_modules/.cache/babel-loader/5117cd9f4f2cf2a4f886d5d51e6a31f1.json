{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useQuery } from '@tanstack/react-query';\nimport { default as fetchData } from 'graphql-fetcher';\n/** ordering argument of a cursor */\nexport let Cursor_Ordering;\n\n/** mutation root */\n(function (Cursor_Ordering) {\n  Cursor_Ordering[\"Asc\"] = \"ASC\";\n  Cursor_Ordering[\"Desc\"] = \"DESC\";\n})(Cursor_Ordering || (Cursor_Ordering = {}));\n/** column ordering options */\nexport let Order_By;\n(function (Order_By) {\n  Order_By[\"Asc\"] = \"asc\";\n  Order_By[\"AscNullsFirst\"] = \"asc_nulls_first\";\n  Order_By[\"AscNullsLast\"] = \"asc_nulls_last\";\n  Order_By[\"Desc\"] = \"desc\";\n  Order_By[\"DescNullsFirst\"] = \"desc_nulls_first\";\n  Order_By[\"DescNullsLast\"] = \"desc_nulls_last\";\n})(Order_By || (Order_By = {}));\n/** unique or primary key constraints on table \"test\" */\nexport let Test_Constraint;\n\n/** input type for incrementing numeric columns in table \"test\" */\n(function (Test_Constraint) {\n  Test_Constraint[\"TestPkey\"] = \"test_pkey\";\n  Test_Constraint[\"TestUsernameKey\"] = \"test_username_key\";\n})(Test_Constraint || (Test_Constraint = {}));\n/** select columns of table \"test\" */\nexport let Test_Select_Column;\n\n/** input type for updating data in table \"test\" */\n(function (Test_Select_Column) {\n  Test_Select_Column[\"Id\"] = \"ID\";\n  Test_Select_Column[\"Password\"] = \"password\";\n  Test_Select_Column[\"Username\"] = \"username\";\n})(Test_Select_Column || (Test_Select_Column = {}));\n/** update columns of table \"test\" */\nexport let Test_Update_Column;\n(function (Test_Update_Column) {\n  Test_Update_Column[\"Id\"] = \"ID\";\n  Test_Update_Column[\"Password\"] = \"password\";\n  Test_Update_Column[\"Username\"] = \"username\";\n})(Test_Update_Column || (Test_Update_Column = {}));\nexport const MyQueryDocument = `\n    query MyQuery {\n  test {\n    ID\n    password\n    username\n  }\n}\n    `;\nexport const useMyQueryQuery = (variables, options) => {\n  _s();\n  return useQuery(variables === undefined ? ['MyQuery'] : ['MyQuery', variables], fetchData(MyQueryDocument, variables), options);\n};\n_s(useMyQueryQuery, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});","map":{"version":3,"names":["useQuery","default","fetchData","Cursor_Ordering","Order_By","Test_Constraint","Test_Select_Column","Test_Update_Column","MyQueryDocument","useMyQueryQuery","variables","options","undefined"],"sources":["A:/Work/PersonalDevelopment/03 {React API}/api_app/src/utils/__generated__/graphql.tsx"],"sourcesContent":["import { useQuery, UseQueryOptions } from '@tanstack/react-query';\nimport { default as fetchData } from 'graphql-fetcher';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n};\n\n/** Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'. */\nexport type Int_Comparison_Exp = {\n  _eq?: InputMaybe<Scalars['Int']>;\n  _gt?: InputMaybe<Scalars['Int']>;\n  _gte?: InputMaybe<Scalars['Int']>;\n  _in?: InputMaybe<Array<Scalars['Int']>>;\n  _is_null?: InputMaybe<Scalars['Boolean']>;\n  _lt?: InputMaybe<Scalars['Int']>;\n  _lte?: InputMaybe<Scalars['Int']>;\n  _neq?: InputMaybe<Scalars['Int']>;\n  _nin?: InputMaybe<Array<Scalars['Int']>>;\n};\n\n/** Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'. */\nexport type String_Comparison_Exp = {\n  _eq?: InputMaybe<Scalars['String']>;\n  _gt?: InputMaybe<Scalars['String']>;\n  _gte?: InputMaybe<Scalars['String']>;\n  /** does the column match the given case-insensitive pattern */\n  _ilike?: InputMaybe<Scalars['String']>;\n  _in?: InputMaybe<Array<Scalars['String']>>;\n  /** does the column match the given POSIX regular expression, case insensitive */\n  _iregex?: InputMaybe<Scalars['String']>;\n  _is_null?: InputMaybe<Scalars['Boolean']>;\n  /** does the column match the given pattern */\n  _like?: InputMaybe<Scalars['String']>;\n  _lt?: InputMaybe<Scalars['String']>;\n  _lte?: InputMaybe<Scalars['String']>;\n  _neq?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given case-insensitive pattern */\n  _nilike?: InputMaybe<Scalars['String']>;\n  _nin?: InputMaybe<Array<Scalars['String']>>;\n  /** does the column NOT match the given POSIX regular expression, case insensitive */\n  _niregex?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given pattern */\n  _nlike?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given POSIX regular expression, case sensitive */\n  _nregex?: InputMaybe<Scalars['String']>;\n  /** does the column NOT match the given SQL regular expression */\n  _nsimilar?: InputMaybe<Scalars['String']>;\n  /** does the column match the given POSIX regular expression, case sensitive */\n  _regex?: InputMaybe<Scalars['String']>;\n  /** does the column match the given SQL regular expression */\n  _similar?: InputMaybe<Scalars['String']>;\n};\n\n/** ordering argument of a cursor */\nexport enum Cursor_Ordering {\n  /** ascending ordering of the cursor */\n  Asc = 'ASC',\n  /** descending ordering of the cursor */\n  Desc = 'DESC'\n}\n\n/** mutation root */\nexport type Mutation_Root = {\n  __typename?: 'mutation_root';\n  /** delete data from the table: \"test\" */\n  delete_test?: Maybe<Test_Mutation_Response>;\n  /** delete single row from the table: \"test\" */\n  delete_test_by_pk?: Maybe<Test>;\n  /** insert data into the table: \"test\" */\n  insert_test?: Maybe<Test_Mutation_Response>;\n  /** insert a single row into the table: \"test\" */\n  insert_test_one?: Maybe<Test>;\n  /** update data of the table: \"test\" */\n  update_test?: Maybe<Test_Mutation_Response>;\n  /** update single row of the table: \"test\" */\n  update_test_by_pk?: Maybe<Test>;\n  /** update multiples rows of table: \"test\" */\n  update_test_many?: Maybe<Array<Maybe<Test_Mutation_Response>>>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_TestArgs = {\n  where: Test_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootDelete_Test_By_PkArgs = {\n  ID: Scalars['Int'];\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_TestArgs = {\n  objects: Array<Test_Insert_Input>;\n  on_conflict?: InputMaybe<Test_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootInsert_Test_OneArgs = {\n  object: Test_Insert_Input;\n  on_conflict?: InputMaybe<Test_On_Conflict>;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_TestArgs = {\n  _inc?: InputMaybe<Test_Inc_Input>;\n  _set?: InputMaybe<Test_Set_Input>;\n  where: Test_Bool_Exp;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Test_By_PkArgs = {\n  _inc?: InputMaybe<Test_Inc_Input>;\n  _set?: InputMaybe<Test_Set_Input>;\n  pk_columns: Test_Pk_Columns_Input;\n};\n\n\n/** mutation root */\nexport type Mutation_RootUpdate_Test_ManyArgs = {\n  updates: Array<Test_Updates>;\n};\n\n/** column ordering options */\nexport enum Order_By {\n  /** in ascending order, nulls last */\n  Asc = 'asc',\n  /** in ascending order, nulls first */\n  AscNullsFirst = 'asc_nulls_first',\n  /** in ascending order, nulls last */\n  AscNullsLast = 'asc_nulls_last',\n  /** in descending order, nulls first */\n  Desc = 'desc',\n  /** in descending order, nulls first */\n  DescNullsFirst = 'desc_nulls_first',\n  /** in descending order, nulls last */\n  DescNullsLast = 'desc_nulls_last'\n}\n\nexport type Query_Root = {\n  __typename?: 'query_root';\n  /** fetch data from the table: \"test\" */\n  test: Array<Test>;\n  /** fetch aggregated fields from the table: \"test\" */\n  test_aggregate: Test_Aggregate;\n  /** fetch data from the table: \"test\" using primary key columns */\n  test_by_pk?: Maybe<Test>;\n};\n\n\nexport type Query_RootTestArgs = {\n  distinct_on?: InputMaybe<Array<Test_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Test_Order_By>>;\n  where?: InputMaybe<Test_Bool_Exp>;\n};\n\n\nexport type Query_RootTest_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Test_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Test_Order_By>>;\n  where?: InputMaybe<Test_Bool_Exp>;\n};\n\n\nexport type Query_RootTest_By_PkArgs = {\n  ID: Scalars['Int'];\n};\n\nexport type Subscription_Root = {\n  __typename?: 'subscription_root';\n  /** fetch data from the table: \"test\" */\n  test: Array<Test>;\n  /** fetch aggregated fields from the table: \"test\" */\n  test_aggregate: Test_Aggregate;\n  /** fetch data from the table: \"test\" using primary key columns */\n  test_by_pk?: Maybe<Test>;\n  /** fetch data from the table in a streaming manner : \"test\" */\n  test_stream: Array<Test>;\n};\n\n\nexport type Subscription_RootTestArgs = {\n  distinct_on?: InputMaybe<Array<Test_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Test_Order_By>>;\n  where?: InputMaybe<Test_Bool_Exp>;\n};\n\n\nexport type Subscription_RootTest_AggregateArgs = {\n  distinct_on?: InputMaybe<Array<Test_Select_Column>>;\n  limit?: InputMaybe<Scalars['Int']>;\n  offset?: InputMaybe<Scalars['Int']>;\n  order_by?: InputMaybe<Array<Test_Order_By>>;\n  where?: InputMaybe<Test_Bool_Exp>;\n};\n\n\nexport type Subscription_RootTest_By_PkArgs = {\n  ID: Scalars['Int'];\n};\n\n\nexport type Subscription_RootTest_StreamArgs = {\n  batch_size: Scalars['Int'];\n  cursor: Array<InputMaybe<Test_Stream_Cursor_Input>>;\n  where?: InputMaybe<Test_Bool_Exp>;\n};\n\n/** test table for api */\nexport type Test = {\n  __typename?: 'test';\n  ID: Scalars['Int'];\n  password: Scalars['String'];\n  username: Scalars['String'];\n};\n\n/** aggregated selection of \"test\" */\nexport type Test_Aggregate = {\n  __typename?: 'test_aggregate';\n  aggregate?: Maybe<Test_Aggregate_Fields>;\n  nodes: Array<Test>;\n};\n\n/** aggregate fields of \"test\" */\nexport type Test_Aggregate_Fields = {\n  __typename?: 'test_aggregate_fields';\n  avg?: Maybe<Test_Avg_Fields>;\n  count: Scalars['Int'];\n  max?: Maybe<Test_Max_Fields>;\n  min?: Maybe<Test_Min_Fields>;\n  stddev?: Maybe<Test_Stddev_Fields>;\n  stddev_pop?: Maybe<Test_Stddev_Pop_Fields>;\n  stddev_samp?: Maybe<Test_Stddev_Samp_Fields>;\n  sum?: Maybe<Test_Sum_Fields>;\n  var_pop?: Maybe<Test_Var_Pop_Fields>;\n  var_samp?: Maybe<Test_Var_Samp_Fields>;\n  variance?: Maybe<Test_Variance_Fields>;\n};\n\n\n/** aggregate fields of \"test\" */\nexport type Test_Aggregate_FieldsCountArgs = {\n  columns?: InputMaybe<Array<Test_Select_Column>>;\n  distinct?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** aggregate avg on columns */\nexport type Test_Avg_Fields = {\n  __typename?: 'test_avg_fields';\n  ID?: Maybe<Scalars['Float']>;\n};\n\n/** Boolean expression to filter rows from the table \"test\". All fields are combined with a logical 'AND'. */\nexport type Test_Bool_Exp = {\n  ID?: InputMaybe<Int_Comparison_Exp>;\n  _and?: InputMaybe<Array<Test_Bool_Exp>>;\n  _not?: InputMaybe<Test_Bool_Exp>;\n  _or?: InputMaybe<Array<Test_Bool_Exp>>;\n  password?: InputMaybe<String_Comparison_Exp>;\n  username?: InputMaybe<String_Comparison_Exp>;\n};\n\n/** unique or primary key constraints on table \"test\" */\nexport enum Test_Constraint {\n  /** unique or primary key constraint on columns \"ID\" */\n  TestPkey = 'test_pkey',\n  /** unique or primary key constraint on columns \"username\" */\n  TestUsernameKey = 'test_username_key'\n}\n\n/** input type for incrementing numeric columns in table \"test\" */\nexport type Test_Inc_Input = {\n  ID?: InputMaybe<Scalars['Int']>;\n};\n\n/** input type for inserting data into table \"test\" */\nexport type Test_Insert_Input = {\n  ID?: InputMaybe<Scalars['Int']>;\n  password?: InputMaybe<Scalars['String']>;\n  username?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate max on columns */\nexport type Test_Max_Fields = {\n  __typename?: 'test_max_fields';\n  ID?: Maybe<Scalars['Int']>;\n  password?: Maybe<Scalars['String']>;\n  username?: Maybe<Scalars['String']>;\n};\n\n/** aggregate min on columns */\nexport type Test_Min_Fields = {\n  __typename?: 'test_min_fields';\n  ID?: Maybe<Scalars['Int']>;\n  password?: Maybe<Scalars['String']>;\n  username?: Maybe<Scalars['String']>;\n};\n\n/** response of any mutation on the table \"test\" */\nexport type Test_Mutation_Response = {\n  __typename?: 'test_mutation_response';\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars['Int'];\n  /** data from the rows affected by the mutation */\n  returning: Array<Test>;\n};\n\n/** on_conflict condition type for table \"test\" */\nexport type Test_On_Conflict = {\n  constraint: Test_Constraint;\n  update_columns?: Array<Test_Update_Column>;\n  where?: InputMaybe<Test_Bool_Exp>;\n};\n\n/** Ordering options when selecting data from \"test\". */\nexport type Test_Order_By = {\n  ID?: InputMaybe<Order_By>;\n  password?: InputMaybe<Order_By>;\n  username?: InputMaybe<Order_By>;\n};\n\n/** primary key columns input for table: test */\nexport type Test_Pk_Columns_Input = {\n  ID: Scalars['Int'];\n};\n\n/** select columns of table \"test\" */\nexport enum Test_Select_Column {\n  /** column name */\n  Id = 'ID',\n  /** column name */\n  Password = 'password',\n  /** column name */\n  Username = 'username'\n}\n\n/** input type for updating data in table \"test\" */\nexport type Test_Set_Input = {\n  ID?: InputMaybe<Scalars['Int']>;\n  password?: InputMaybe<Scalars['String']>;\n  username?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate stddev on columns */\nexport type Test_Stddev_Fields = {\n  __typename?: 'test_stddev_fields';\n  ID?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type Test_Stddev_Pop_Fields = {\n  __typename?: 'test_stddev_pop_fields';\n  ID?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type Test_Stddev_Samp_Fields = {\n  __typename?: 'test_stddev_samp_fields';\n  ID?: Maybe<Scalars['Float']>;\n};\n\n/** Streaming cursor of the table \"test\" */\nexport type Test_Stream_Cursor_Input = {\n  /** Stream column input with initial value */\n  initial_value: Test_Stream_Cursor_Value_Input;\n  /** cursor ordering */\n  ordering?: InputMaybe<Cursor_Ordering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type Test_Stream_Cursor_Value_Input = {\n  ID?: InputMaybe<Scalars['Int']>;\n  password?: InputMaybe<Scalars['String']>;\n  username?: InputMaybe<Scalars['String']>;\n};\n\n/** aggregate sum on columns */\nexport type Test_Sum_Fields = {\n  __typename?: 'test_sum_fields';\n  ID?: Maybe<Scalars['Int']>;\n};\n\n/** update columns of table \"test\" */\nexport enum Test_Update_Column {\n  /** column name */\n  Id = 'ID',\n  /** column name */\n  Password = 'password',\n  /** column name */\n  Username = 'username'\n}\n\nexport type Test_Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<Test_Inc_Input>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<Test_Set_Input>;\n  where: Test_Bool_Exp;\n};\n\n/** aggregate var_pop on columns */\nexport type Test_Var_Pop_Fields = {\n  __typename?: 'test_var_pop_fields';\n  ID?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate var_samp on columns */\nexport type Test_Var_Samp_Fields = {\n  __typename?: 'test_var_samp_fields';\n  ID?: Maybe<Scalars['Float']>;\n};\n\n/** aggregate variance on columns */\nexport type Test_Variance_Fields = {\n  __typename?: 'test_variance_fields';\n  ID?: Maybe<Scalars['Float']>;\n};\n\nexport type MyQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type MyQueryQuery = { __typename?: 'query_root', test: Array<{ __typename?: 'test', ID: number, password: string, username: string }> };\n\n\nexport const MyQueryDocument = `\n    query MyQuery {\n  test {\n    ID\n    password\n    username\n  }\n}\n    `;\nexport const useMyQueryQuery = <\n      TData = MyQueryQuery,\n      TError = unknown\n    >(\n      variables?: MyQueryQueryVariables,\n      options?: UseQueryOptions<MyQueryQuery, TError, TData>\n    ) =>\n    useQuery<MyQueryQuery, TError, TData>(\n      variables === undefined ? ['MyQuery'] : ['MyQuery', variables],\n      fetchData<MyQueryQuery, MyQueryQueryVariables>(MyQueryDocument, variables),\n      options\n    );"],"mappings":";AAAA,SAASA,QAAQ,QAAyB,uBAAuB;AACjE,SAASC,OAAO,IAAIC,SAAS,QAAQ,iBAAiB;AA6DtD;AACA,WAAYC,eAAe;;AAO3B;AAAA,WAPYA,eAAe;EAAfA,eAAe;EAAfA,eAAe;AAAA,GAAfA,eAAe,KAAfA,eAAe;AA0E3B;AACA,WAAYC,QAAQ;AAanB,WAbWA,QAAQ;EAARA,QAAQ;EAARA,QAAQ;EAARA,QAAQ;EAARA,QAAQ;EAARA,QAAQ;EAARA,QAAQ;AAAA,GAARA,QAAQ,KAARA,QAAQ;AAgJpB;AACA,WAAYC,eAAe;;AAO3B;AAAA,WAPYA,eAAe;EAAfA,eAAe;EAAfA,eAAe;AAAA,GAAfA,eAAe,KAAfA,eAAe;AA+D3B;AACA,WAAYC,kBAAkB;;AAS9B;AAAA,WATYA,kBAAkB;EAAlBA,kBAAkB;EAAlBA,kBAAkB;EAAlBA,kBAAkB;AAAA,GAAlBA,kBAAkB,KAAlBA,kBAAkB;AAuD9B;AACA,WAAYC,kBAAkB;AAO7B,WAPWA,kBAAkB;EAAlBA,kBAAkB;EAAlBA,kBAAkB;EAAlBA,kBAAkB;AAAA,GAAlBA,kBAAkB,KAAlBA,kBAAkB;AAyC9B,OAAO,MAAMC,eAAe,GAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,OAAO,MAAMC,eAAe,GAAG,CAIzBC,SAAiC,EACjCC,OAAsD;EAAA;EAAA,OAExDX,QAAQ,CACNU,SAAS,KAAKE,SAAS,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,EAAEF,SAAS,CAAC,EAC9DR,SAAS,CAAsCM,eAAe,EAAEE,SAAS,CAAC,EAC1EC,OAAO,CACR;AAAA;AAAC,GAXOF,eAAe;EAAA,QAOxBT,QAAQ;AAAA"},"metadata":{},"sourceType":"module"}